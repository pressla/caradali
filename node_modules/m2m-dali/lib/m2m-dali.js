//m2m_dali.js
//Alex Pressl for imitrix GmbH

// Declare internals

var Path = require('path');
var Async = require('async');
var Dgram = require('dgram');
var exec		= require('child_process').exec;
var fs = require('fs');

var     mactable = {nodes:[]};

var Emitter = require('events').EventEmitter;
var Relay = new Emitter();
var sub  = Dgram.createSocket('udp4');

var DaliSeq = require ('./dali-sequences');
var myApp = {};
var mySelf = {};
var internals = {
	initialized:false,
	multicastID: '239.1.1.200',
    multicastClientID: '239.1.1.201',
	targetPort:  61088
};

var socketlog=require('./m2m-socket-log.js');
/*
socketlog.options.mac           = mac;
socketlog.options.firmversion   = firmversion;
socketlog.options.configversion = configversion;
socketlog.options.config        = config;
*/

socketlog.push(); //this will start the interval logging


var mactablefilename = '/etc/config/mactablem2m.json';
var persist = {restart_count:0};

var fs = require('fs');
var net = require('net');
var sockets = [];


exports.initPlugin = function (m2mApp, options, next) {

 	if (internals.initialized) {
        return next();
    }
    myApp = m2mApp;
    myApp.next = next;
    myApp.logger.log('info','m2m-dali START CONTROLLER');
    var settings = m2mUtilsApplyToDefaults(internals, options);

    myGrouping = {name:'L1', group:'G1'};
    myCurrentLevel = 0;


    setParams();

    if (myApp.node_id == 'C4:93:00:00:00:00') {
        mactablefilename = '/home/al/git/caradali/test/mactablem2m.json';
    }

    var udpOptions = {
        address:'localhost',
        port:       internals.targetPort,
        exclusive:true
    }

    // Application socket interface
    net.createServer(function(socket){
        sockets.push(socket);
        socket.write('hello\n');
        socket.on('data', function(data){
            var i;
            var cmd ={};
            for (i=0; i < sockets.length; i++){
                if (sockets[i] === socket)  continue;
            }
                //socket.write('ack:'+data.toString());
                cmd.data = data.toString();
                cmd.socket = socket;
                Relay.emit('socketcmd', cmd);    //Fire the event for each command
        });
        socket.on('end', function(){
            var i = sockets.indexOf(socket);
            sockets.remove(i);
        });
    }).listen(61000);

    try{    //bind to multicast messages
        sub.bind(internals.targetPort, function () {
            sub.addMembership(internals.multicastID);     //listen to this group  
            sub.setMulticastTTL(255);
            sub.setTTL(255);
            sub.setMulticastLoopback(false);
            myApp.logger.log('info','server registered to listen to multicast ip: '+internals.multicastID+'  TTL 255');
        });
    } catch (e) { myApp.logger.log('error','EXCEPTION BIND MULTICAST: '+e);}

	sub.on('listening', function () {
    	var address = sub.address();
    	//myApp.logger.log('info','UDP listening ' + address.address + ":" + address.port);
	});

    sub.on('close', function () {
        myApp.logger.log('error','UDP no more listening CLOSE EVENT FIRED' );
    });

    sub.on('error', function (err) {
        myApp.logger.log('error','UDP ERROR EVENT FIRED: '+err );
    });

	//callback for multicast messages coming in
    sub.on('message', function (buf, rinfo) {

        //console.log(buf.toString('ascii',0,4));
        if (buf.toString('ascii',0,4) == 'FILE') {      // file transfer coming in
            var b = new Buffer(buf).toString('ascii');
            var arg = b.split('~');
            //console.log(JSON.stringify(arg));
            var fname = arg[1];
            var file = arg[2];
            myApp.logger.log('info','file received '+fname);
            var fileforme = true;
            //myApp.logger.log('info', file);
            var f = JSON.parse(file);
            for (i in file.nodes) {
                if (file.nodes[i].node_id == myApp.node_id) {   // for me?
                    fileforme=true;
                }
            }
            if (fileforme == true) {
                try {
                    fs.writeFileSync(fname,file);
                } catch(e) {
                    myApp.logger.log('error', 'file write on multicast failed: '+e);
                }
            } else {
                myApp.logger.log('info', 'file is not for me');
                return;
            }



            //sub.send(buf, 0, buf.length,internals.targetPort, internals.multicastID);
            //myApp.logger.log('info','forward file'+buf.toString());
            setTimeout(setParams, 20000);   //wait 20s sec and update to the new params
            //setParams();
            return;
        }

    	var buff = new Buffer(buf).toString('ascii');
    	var obj = buff.split(',');
    	console.log(JSON.stringify(obj));
		if (obj.length > 3) {	
			if (obj[3] == myApp.node_id) return;  //nothing to yourself. this message was forwarded by me
		}   	

        setTimeout(lastArgReset, 5000); // do not accept same command for 5 seconds.

    	obj.push(rinfo);

		if (obj[0] == 'ping') {   //is it a ping request?
			var sres = 'pong,'+obj[1]+','+myApp.node_id+','+obj[2];
		    var res = new Buffer(sres);
		    //sub.send(res, 0, res.length, internals.targetPort, internals.multicastID);
		} else {
            if ((lastarg1 == obj[1]) && (lastarg2 == obj[2])) {
                //myApp.logger.log('info','ignored '+obj[1]+','+obj[2]);

            }else{
                Relay.emit(obj[0], obj);    //FINALLY ! Fire the event for each command
                lastarg1=obj[1];
                lastarg2=obj[2];
            }
	    }

        // forwarding, tell the others about the message
		if (obj.length <= 4) {  //rinfo is already added so 3+1
			buff = buff+','+myApp.node_id;	//add your ID to mark it is a forward
			var buffy = new Buffer(buff);
			sub.send(buffy, 0, buffy.length,internals.targetPort, internals.multicastID);
			myApp.logger.log('info','forward '+buffy.toString());
		}
	});

    var daliconfig = require('./m2m-dali.config')
    DaliSeq.initSeq(myApp, daliconfig.serialdev);
    setTimeout(initme, 10000);



};

//bullshit
var lastarg1=0;
var lastarg2=0;
function lastArgReset(){
    lastarg1=0;
    lastarg2=0;
}



var test = false;
function initme() {
    myApp.logger.log('info','LET THE DOGS OUT !');
    DaliSeq.executeSeq(DaliSeq.seq.On);
    //setInterval(blink, 60000);
    //callBash('/etc/init.d/firewall stop');
    myApp.next();
}


	//**********************  events processing *******************
Relay.on('switch', function (msg) {
    //msg[1] = group ID (G0,G1..G99) G99 is all lights
    //msg[2] = brightness for switch command
    if (msg[1]==myGrouping.group || msg[1]==myGrouping.name || msg[1]=='G99') {

        myApp.logger.log('info',myApp.node_id+' switch ' + msg[1] + ':' + msg[2]);
        var b = msg[2]; //brightness

        if (b<10) DaliSeq.executeSeq(DaliSeq.seq.Off);
        if (b>=10 && b<=25) DaliSeq.executeSeq(DaliSeq.seq.Min);
        if (b>25 && b<=50) DaliSeq.executeSeq(DaliSeq.seq.DimDown);
        if (b>50 && b<=75) DaliSeq.executeSeq(DaliSeq.seq.DimUp);
        if (b>75 && b<=90) DaliSeq.executeSeq(DaliSeq.seq.DimUp);
        if (b>90) DaliSeq.executeSeq(DaliSeq.seq.On);

    }
});	

Relay.on('TEST', function (msg) {
    //msg[1] = group ID (G0,G1..G99) G99 is all lights, G0 is dont care
    //msg[2] = mac address for TEST command
    //TEST,G0,00:00:00:00:00:00 switches on a light for 5 seconds, identified by mac address

    if (msg[2]==myApp.node_id) {
        myApp.logger.log('info',myApp.node_id+'execute TEST ' + msg[1] + ':' + msg[2]);

        DaliSeq.executeSeq(DaliSeq.seq.Test);
    }
}); 

var frame;

//*************************** multicast events **************************
//incoming multicast command:
Relay.on('sendcmd', function (msg) {
    myApp.logger.log('info',myApp.node_id+' SENDCMD ' + msg[1] + ':' + msg[2]+JSON.stringify(msg));
    if (internals.initialized == true) {
        //sendSeq(msg);
    }
}); 

//bullshit
Relay.on('query', function (msg) {
    myApp.logger.log('info','From: ' + msg[3].address + ':' + msg[3].port + ' - ' + 'query ' + msg[1] + ':' + msg[2]);
    if (msg[1] == 'G1') {
        send('query', 'G1', msg[2], ['G2', 'G4', 'G7'], msg[3]);
    }
});

//receive mactable file and store to disk
Relay.on('setwifiparam', function (msg) {
    myApp.logger.log('info',myApp.node_id+' setwifiparam ' + msg[1] + ':' + msg[2]);
    param = msg; //array of key,value
    if (param[1]=='mactable') {  //{'mactable', {param:'', value:''}
        //console.log(JSON.stringify(param,null,4));
        writemactable('wifiparam', param[2]);
    }
});

//execute a console command remotely
Relay.on('callBash', function (msg) {
    myApp.logger.log('info',myApp.node_id+' callBash ' + msg[1] + ':' + msg[2]);
    callBash(msg[1]);
});

//************************* socket events ************************************

//incoming socket communication:
Relay.on('socketcmd', function (cmd) {
    //cmd.data is the message body
    //cmd.socket is the socket for reply
    myApp.logger.log('info',myApp.node_id+' SOCKETCMD ' +cmd.socket+ cmd.data);
    if (internals.initialized == true) {
        //TODO: socket commands for direct client connection
        var s = cmd.data.split(',');
        Relay.emit(s[0], s);    //FINALLY ! Fire the event for each command
        cmd.socket.write('OK:'+s);
        
    }
}); 

//read mactablem2m file and apply changes to system.
var setParams = function () {

    var mactable = 0;
    try {mactable = JSON.parse(fs.readFileSync(mactablefilename, 'utf8'));} catch (e){console.log('file read error '+e); return;}
    //myApp.logger.log('info',JSON.stringify(mactable,null,2));
    for (i in mactable.nodes) {
        if (mactable.nodes[i].node_id == myApp.node_id) {   // for me?
            notme=false;
            //console.log('its me')
            for (x in mactable.nodes[i].param) {
                var p = mactable.nodes[i].param[x];
                if (p.type == 'myGrouping') { //set group
                    myGrouping[p.param] = p.value;
                    myApp.logger.log('info', 'myGrouping Set to '+p.param+':'+p.value);
                }else {     //parameter twaeking
                    try {
                        var cmd = p.type.replace(/%/g,' ');  //uci%set%wireless.mesh.mesh_id
                        var pa  = p.param+'='+p.value;
                        callBash(cmd+' '+pa);
                    } catch (e) {
                        myApp.logger.log('info','Invalid parameters: '+p);

                    }
                }
            }
            callBash('uci commit wireless');
            callBash('uci commit network');
            callBash('wifi');
            myApp.logger.log('info','Parameters read and applied');
        }else {
            notme=true;
        }
    }
    if (notme) myApp.logger.log('info','mactable parameters are not for me');
    else myApp.logger.log('info','read new mactable parameters for me');


}

function callBash(cmdline) {
    myApp.logger.log('info',cmdline);
    exec(cmdline,
        function(error,stdout,stderr) {
            if (error) myApp.logger.log('error','CANNOT execute CMD: '+cmdline);
            else myApp.logger.log('info',stdout);
        }
    );
}

//unused
function send() {
    var args = [].slice.call(arguments);
    var fn = typeof args[args.length - 1] == 'function' ? args.pop() : null;
    var port = args[4].port;
    var address = args[4].address;
    var msg = (args.join(','));
    var buf = new Buffer(msg);
    myPlugin.log('info',msg);
    sub.send(buf, 0, buf.length, port, address, fn);
};

function m2mUtilsApplyToDefaults(current, update){
    for (var key in update) {
       if (update.hasOwnProperty(key)) {
          current[key] = update[key];
          myApp.logger.log('info','[m2mUtilsApplyToDefaults]: '+key+'  = '+update[key]);
       }
    }
    current.initialized = true;
}



var one=false;
function blink() {
    //callBash('/etc/init.d/firewall stop');
    if (test==false) return;

    if (one==true) {
        DaliSeq.executeSeq(DaliSeq.seq.On);
        one =false;
    }else{
        DaliSeq.executeSeq(DaliSeq.seq.Off);
        one=true;
    }
}

// Array Remove - By John Resig (MIT Licensed)
Array.prototype.remove = function(from, to) {
  var rest = this.slice((to || from) + 1 || this.length);
  this.length = from < 0 ? this.length + from : from;
  return this.push.apply(this, rest);
};