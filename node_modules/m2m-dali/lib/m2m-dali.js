//m2m_dali.js
//Alex Pressl for imitrix GmbH

// Declare internals

//var findKey = require('lodash.findkey');
var Path = require('path');
var Async = require('async');
var Dgram = require('dgram');
var exec		= require('child_process').exec;
var fs = require('fs');

var     mactable = {nodes:[]};

var Emitter = require('events').EventEmitter;
var Relay = new Emitter();
var sub  = Dgram.createSocket('udp4');

var DaliSeq = require ('./dali-sequences');
var myApp = {};
var mySelf = {};
var internals = {
	initialized:false,
	multicastID: '239.1.1.200',
    multicastClientID: '239.1.1.201',
	targetPort:  61088
};

var mactablefilename = '/etc/config/mactablem2m.json';
var persist = {restart_count:0};

var fs = require('fs');
function configSave() {
    fs.writeFile('dali-groups.config', JSON.stringify(groups), function(err) {
        if (err) myApp.logger('error', 'error writing group config');
    });
    fs.writeFile('dali-nodes.config', JSON.stringify(nodes), function(err) {
        if (err) myApp.logger('error', 'error writing nodes config');
    });
}

function configLoad() {
    fs.readFileSync('dali-groups.config', function(err,data) {
        if (!err) {
            groups = JSON.parse(data);
        } else {
            myApp.logger.log('error', 'error reading group config');
        }
    });
    fs.readFileSync('dali-nodes.config', function(err,data) {
        if (!err) {
            nodes = JSON.parse(data);
        } else {
            myApp.logger.log('error', 'error reading nodes config');
        }
    });
}

function m2mUtilsApplyToDefaults(current, update){
	for (var key in update) {
	   if (update.hasOwnProperty(key)) {
	      current[key] = update[key];
	      myApp.logger.log('info','[m2mUtilsApplyToDefaults]: '+key+'  = '+update[key]);
	   }
	}
    current.initialized = true;
}

function persistentCache(what) {
    if (what=='get') {
        try {
            fs.readFileSync('/root/m2m_persist.json', function(err,data) {
                if (!err) {
                    persist = JSON.parse(data);
                } else {
                    myApp.logger.log('error', 'error reading persist cache');
                }
            });
        } catch (e) {myApp.logger.log('error', 'EXCEPTION reading persistent cache'+e);}
    }
    if (what=='set') {
        try {
            fs.writeFile('/root/m2m_persist.json', JSON.stringify(persist), function(err) {
                if (err) myApp.logger.log('error', 'error writing persistent cache');
            });
        } catch (e) {myApp.logger.log('error', 'error reading restart counter'+e);}
    }
}


exports.initPlugin = function (m2mApp, options, next) {

 	if (internals.initialized) {
        return next();
    }
    myApp = m2mApp;
    myApp.next = next;
    myApp.logger.log('info','m2m-dali START CONTROLLER');
    var settings = m2mUtilsApplyToDefaults(internals, options);

    persistentCache('get');
    persist.restart_count++;
    persistentCache('set');

    myGrouping = {name:'L1', group:'G1'};
    myCurrentLevel = 0;


    setParams();

    if (myApp.node_id == 'C4:93:00:00:00:00') {
        mactablefilename = '/home/al/git/caradali/test/mactablem2m.json';
    }

    var udpOptions = {
        address:'localhost',
        port:       internals.targetPort,
        exclusive:true
    }

    try{
        sub.bind(internals.targetPort, function () {
            sub.addMembership(internals.multicastID);     //listen to this group  
            sub.setMulticastTTL(255);
            sub.setTTL(255);
            sub.setMulticastLoopback(false);
            myApp.logger.log('info','server registered to listen to multicast ip: '+internals.multicastID+'  TTL 255');
        });
    } catch (e) { myApp.logger.log('error','EXCEPTION BIND MULTICAST: '+e);}

	sub.on('listening', function () {
    	var address = sub.address();
    	myApp.logger.log('info','UDP listening ' + address.address + ":" + address.port);
	});

    sub.on('close', function () {
        myApp.logger.log('error','UDP no more listening CLOSE EVENT FIRED' );
    });

    sub.on('error', function (err) {
        myApp.logger.log('error','UDP ERROR EVENT FIRED: '+err );
    });

	sub.on('message', function (buf, rinfo) {

        //console.log(buf.toString('ascii',0,4));
        if (buf.toString('ascii',0,4) == 'FILE') {      // file transfer coming in
            var b = new Buffer(buf).toString('ascii');
            var arg = b.split('~');
            //console.log(JSON.stringify(arg));
            var fname = arg[1];
            var file = arg[2];
            myApp.logger.log('info','file received '+fname);
            try {
                fs.writeFileSync(fname,file);
            } catch(e) {
                myApp.logger.log('error', 'file write on multicast failed: '+e);
            }
            //sub.send(buf, 0, buf.length,internals.targetPort, internals.multicastID);
            //myApp.logger.log('info','forward file'+buf.toString());
            setParams();
            return;
        }

    	var buff = new Buffer(buf).toString('ascii');
    	var obj = buff.split(',');
    	console.log(JSON.stringify(obj));
		if (obj.length > 3) {	
			if (obj[3] == myApp.node_id) return;  //nothing to yourself
		}   	

        setTimeout(lastArgReset, 5000);

    	obj.push(rinfo);
		if (obj[0] == 'ping') {
			var sres = 'pong,'+obj[1]+','+myApp.node_id+','+obj[2];
		    var res = new Buffer(sres);
		    //sub.send(res, 0, res.length, internals.targetPort, internals.multicastID);
		} else {
            if ((lastarg1 == obj[1]) && (lastarg2 == obj[2])) {
                //myApp.logger.log('info','ignored '+obj[1]+','+obj[2]);

            }else{
                Relay.emit(obj[0], obj);    //Fire the event for each command
                lastarg1=obj[1];
                lastarg2=obj[2];
            }
	    }


		if (obj.length <= 4) {  //rinfo is already added so 3+1
			buff = buff+','+myApp.node_id;	//add your ID to mark it is a forward
			var buffy = new Buffer(buff);
			sub.send(buffy, 0, buffy.length,internals.targetPort, internals.multicastID);
			myApp.logger.log('info','forward '+buffy.toString());
		}
	});

    var daliconfig = require('./m2m-dali.config')
    DaliSeq.initSeq(myApp, daliconfig.serialdev);
    setTimeout(initme, 10000);
    setInterval(life,30000);



};
var lastarg1=0;
var lastarg2=0;
function lastArgReset(){
    lastarg1=0;
    lastarg2=0;
}

function life () {
    var cversion = '---'
    try {cversion = fs.readFileSync('/etc/config/config_version', 'ascii').replace('\n','');} catch (e) {cversion = '---';}

    var state = {};
    try {
        exec("uci show wireless",
        function(error,stdout,stderr) {
            state.dump='stdout'+stderr;
            if (error == null) {
                var lines = stdout.split('\n');
                for (l in lines) {
                    var keyval=lines[l].split('=');
                    if (keyval[0]=='wireless.radio0.channel') state.channel = keyval[1];
                    if (keyval[0]=='wireless.@wifi-iface[0].ssid') state.ssid = keyval[1];
                    if (keyval[0]=='wireless.mesh.mesh_id') state.mesh_id = keyval[1];
                }
            } else {
                state.channel = 0;
                state.ssid = 'NOSSID';
                state.mesh_id = 'NOMESHID'
            }
        });
    } catch (e) {
        myApp.logger.log('error', 'NO VALID MESHDUMP '+e);
    }

    state.version = cversion;
    state.restart_count=persist.restart_count;

    myApp.logger.log('state',state);
	try {
        exec("iw meshif mpath dump",
    	function(error,stdout,stderr) {
            var mpath = [];
    		if (error == null) {

    			var lines = stdout.split('\n');
    			//console.log(lines);
    			for (line in lines) {
    				
    				mpath.push(lines[line].replace(/\t/g,' '));
    			}
                myApp.logger.log('mpath', mpath);
    		}
    	});
    } catch (e) {
        myApp.logger.log('error', 'NO VALID MESHDUMP');
    }
    
}


var test = false;
function initme() {
    myApp.logger.log('info','LET THE DOGS OUT !');
    DaliSeq.executeSeq(DaliSeq.seq.On);
    //setInterval(blink, 60000);
    //callBash('/etc/init.d/firewall stop');
    myApp.next();
}


var one=false;

function blink() {
    //callBash('/etc/init.d/firewall stop');
    if (test==false) return;

    if (one==true) {
        DaliSeq.executeSeq(DaliSeq.seq.On);
        one =false;
    }else{
        DaliSeq.executeSeq(DaliSeq.seq.Off);
        one=true;
    }
}
	//**********************  events processing *******************
Relay.on('switch', function (msg) {
    test = false;

    if (1) {//msg[1]==myGroup || msg[1]==myName) {

        myApp.logger.log('info',myApp.node_id+' switch ' + msg[1] + ':' + msg[2]);
        var b = msg[2]; //brightness

        if (b<10) DaliSeq.executeSeq(DaliSeq.seq.Off);
        if (b>=10 && b<=25) DaliSeq.executeSeq(DaliSeq.seq.Min);
        if (b>25 && b<=50) DaliSeq.executeSeq(DaliSeq.seq.DimDown);
        if (b>50 && b<=75) DaliSeq.executeSeq(DaliSeq.seq.DimUp);
        if (b>75 && b<=90) DaliSeq.executeSeq(DaliSeq.seq.DimUp);
        if (b>90) DaliSeq.executeSeq(DaliSeq.seq.On);

    }
});	

var frame;

Relay.on('sendcmd', function (msg) {
    myApp.logger.log('info',myApp.node_id+' SENDCMD ' + msg[1] + ':' + msg[2]+JSON.stringify(msg));
    if (internals.initialized == true) {
        //sendSeq(msg);
    }
}); 


Relay.on('query', function (msg) {
    myApp.logger.log('info','From: ' + msg[3].address + ':' + msg[3].port + ' - ' + 'query ' + msg[1] + ':' + msg[2]);
    if (msg[1] == 'G1') {
        send('query', 'G1', msg[2], ['G2', 'G4', 'G7'], msg[3]);
    }
});

Relay.on('setgroups', function (msg) {
    groups = JSON.parse(msg);
});

Relay.on('setnodes', function (msg) {
    nodes = JSON.parse(msg);
});

Relay.on('setwifiparam', function (msg) {
    myApp.logger.log('info',myApp.node_id+' setwifiparam ' + msg[1] + ':' + msg[2]);
    param = msg; //array of key,value
    if (param[1]=='mactable') {  //{'mactable', {param:'', value:''}
        console.log(JSON.stringify(param,null,4));
        writemactable('wifiparam', param[2]);
    }
});

Relay.on('callBash', function (msg) {
    myApp.logger.log('info',myApp.node_id+' callBash ' + msg[1] + ':' + msg[2]);
    callBash(msg[1]);
});


function setParams() {

    var mactable = 0;
    try {mactable = JSON.parse(fs.readFileSync(mactablefilename, 'utf8'));} catch (e){console.log('file read error '+e); return;}
    //myApp.logger.log('info',JSON.stringify(mactable,null,2));
    for (i in mactable.nodes) {
        if (mactable.nodes[i].node_id == myApp.node_id) {   // for me?
            notme=true;
            //console.log('its me')
            for (x in mactable.nodes[i].param) {
                var p = mactable.nodes[i].param[x];
                if (p.type == 'myGrouping') { //set group
                    myGrouping[p.param] = p.value;
                    myApp.logger.log('info', 'myGrouping Set to '+p.param+':'+p.value);
                }else {     //parameter twaeking
                    try {
                        var cmd = p.type.replace(/%/g,' ');
                        var pa  = p.param+'='+p.value;
                        callBash(cmd+' '+pa);
                    } catch (e) {
                        myApp.logger.log('info','Invalid parameters: '+p);

                    }
                }
            }
            callBash('uci commit wireless');
            callBash('uci commit network');
            callBash('wifi');
            myApp.logger.log('info','Parameters read and applied');
        }else {
            notme=true;
        }
    }
    if (notme) myApp.logger.log('info','mactable parameters are not for me');
    else myApp.logger.log('info','read new mactable parameters for me');


}

function callBash(cmdline) {
    myApp.logger.log('info',cmdline);
    exec(cmdline,
        function(error,stdout,stderr) {
            if (error) myApp.logger.log('error','CANNOT SET PARAMETER: '+cmdline);
        }
    );
}


function send() {
    var args = [].slice.call(arguments);
    var fn = typeof args[args.length - 1] == 'function' ? args.pop() : null;
    var port = args[4].port;
    var address = args[4].address;
    var msg = (args.join(','));
    var buf = new Buffer(msg);
    myPlugin.log('info',msg);
    sub.send(buf, 0, buf.length, port, address, fn);
};


var groups = [

    {name:'G1 Halle 2, Maschine 1'},
    {name:'G2 Halle 2, Maschine 2'},
    {name:'G3 Halle 2, Maschine 3'},
    {name:'G4 Halle 2, Notbeleuchtung'},
    {name:'G5 Halle 2, Alle'},
    {name:'G6 Halle 3, Lager'},
    {name:'G7 Halle 3, Notbeleuchtung'},
    {name:'G8 Halle 4, Notbeleuchtung'},
    {name:'G9 Halle 4, Alle'}

];

var nodes = [
    {node_id:"C4:93:00:02:76:2F",name:"L1",group:"G1"},
    {node_id:"C4:93:00:02:76:74",name:"L2",group:"G1,G2"},
    {node_id:"C4:93:00:02:85:E0",name:"L3",group:"G1,G2"},
    {node_id:"C4:93:00:02:76:44",name:"L4",group:"G2"},
    {node_id:"C4:93:00:02:86:22",name:"L5",group:"G2,G3,G4"},
    {node_id:"C4:93:00:02:85:DD",name:"L6",group:"G1,G4"}
];



