//m2m_socket_log.js
//Alex Pressl for imitrix GmbH

var sPipe = require('m2m-socket-pipe');
var wrt			= require('wrt');
var fs			= require('fs');
var os 			= require('os');
var exec		= require('child_process').exec;
var m2mParam;
//internals
var myApp = {}
myApp.logger = {};
var top			= {};
var meshlog 	= {};
var header 		= {};
var prot 		= [2];
var ifconfig 	= wrt.ifconfig();




//interface
exports.options = options =  {
	mac: 'unknown',
	firmversion: 'unknown',
	configversion: 'unknown',
	m2mParam: 'unknown',
	persist: {restart_count:0}
}

function readSystemData() {
	try {options.mac = fs.readFileSync('/sys/class/ieee80211/phy0/macaddress', 'ascii').replace('\n','');} catch (e) {options.mac = 'c4:93:00:00:00:00';}
	try {options.firmversion = fs.readFileSync('/etc/openwrt_version', 'ascii').replace('\n','');} catch (e) {options.firmversion = 'not found';}
	try {options.configversion = fs.readFileSync('/etc/config/config_version', 'ascii').replace('\n','');} catch (e) {options.configversion = 'not found';}
	try {options.persist=JSON.parse(fs.readFileSync('/root/m2m_persist.json', 'utf8'));} catch (e) {options.persist.restart_count=0;}
}


var site = {
	    last_error_description: "interfaces up",
	    last_error_title: "no error",
	    next: "08-04-2016",
	    node_description: "LED wifi",
	    node_name: "AIM Halle 2",
	    service: "unknown",
	    status: "active",
	    tracker: 0,
	    cpu:{}
	};

exports.push = function() {

	readSystemData();

	myApp.logger.log = function (message, payload){
		sPipe.m2mlog ('M2Mwifi', message, payload);
	}
	try {
		options.m2mParam	= require('/etc/config/m2m_param');
	} catch(err) {
	    if (err) myApp.logger.log('error', 'm2m-socket-log.js, cannot read /etc/config/m2m_param: '+err);

		options.m2mParam =  {
			interval: {
				checkRequestVPN:20000,
				checkFirmware:30000,
				checkConfig:45000,
				ProcessData:36000,
				Passport:86000,
				MeshIf:30000
			}
		}
	}
	sPipe.createLogger (options.mac);
	sPipe.pipeoptions.consoleOutput = true;

	header.timestamp 	= new Date().getTime();
	header.node_id 		= options.mac;

	setInterval(pubProcess, options.m2mParam.interval.ProcessData+Math.random()*30000); pubProcess();

	setInterval(pubPassport, options.m2mParam.interval.Passport+Math.random()*30000); pubPassport();

	setInterval(pubIfconfig, options.m2mParam.interval.MeshIf+Math.random()*30000); pubIfconfig();

	setInterval(pubLife, options.m2mParam.interval.MeshIf+Math.random()*30000); pubLife();

    try {
    	options.persist.restart_count++;
        fs.writeFile('/root/m2m_persist.json', JSON.stringify(options.persist), 'utf8', function(err) {
            if (err) myApp.logger.log('error', 'error writing persistent cache: '+err);
        });
    } catch (e) {myApp.logger.log('error', 'error setting restart counter'+e);}

}

function pubLife () {
    var cversion = '---'
    try {cversion = fs.readFileSync('/etc/config/config_version', 'ascii').replace('\n','');} catch (e) {cversion = '---';}

    var state = {};
    state.version = options.configversion;
    state.firmversion = options.firmversion;
    state.restart_count=options.persist.restart_count;
    try {
        exec("uci show wireless",
        function(error,stdout,stderr) {
            //state.dump='stdout'+stderr;
            if (error == null) {
                var lines = stdout.split('\n');
                for (l in lines) {
                    if (typeof lines[l]=='string'){
                        var keyval=lines[l].split('=');
	                    if (keyval[0]=='wireless.radio0.channel')               state.channel               = keyval[1];
	                    if (keyval[0]=='wireless.ap.ssid')                      state.ssid                  = keyval[1];
	                    if (keyval[0]=='wireless.mesh.mesh_id')                 state.mesh_id               = keyval[1];
	                    if (keyval[0]=='wireless.mesh.mesh_hwmp_rootmode')      state.hwmp_rootmode         = keyval[1];
	                    if (keyval[0]=='wireless.mesh.mesh_gate_announcements') state.gate_announcements    = keyval[1];
                    }
                }
            } else {
                state.channel = 0;
                state.ssid = 'NOSSID';
                state.mesh_id = 'NOMESHID'
                myApp.logger.log('error', 'EXEC Wireless failed ');
            }
            myApp.logger.log('state',state);
        });
    } catch (e) {
        myApp.logger.log('error', 'NO VALID Wireless DUMP '+e);
        myApp.logger.log('state',state);
    }


    try {
        exec("iw meshif mpath dump",
        function(error,stdout,stderr) {
            var mpath = [];
            if (error == null) {
                var lines = stdout.split('\n');
                //console.log(lines);
                for (line in lines) {
	            	if (typeof lines[line]=='string')
	                    mpath.push(lines[line].replace(/\t/g,' '));
                }
                myApp.logger.log('mpath', mpath);
            }
        });
    } catch (e) {
        myApp.logger.log('error', 'NO VALID MESHDUMP');
    }
    
}


function pubIfconfig() {
	var ifconfig 	= wrt.ifconfig();
	myApp.logger.log('ifconfig', ifconfig);
}

function pubPassport() {

	site.os 	= {};
    site.os.hostname = os.hostname();
    site.os.type = os.type();
    site.os.platform = os.platform();
    site.os.arch = os.arch();


    site.version_firmware = 'M2Mwifi '+options.firmversion;

	exec("cat /proc/cpuinfo",
	function(error,stdout,stderr) {
		if (error == null) {
			var lines = stdout.split('\n');
			for (line in lines) {
				if (typeof lines[line] == 'string') {
					var l = lines[line].split(':');
					switch (l[0].trim()) {
						case 'system type':
							site.cpu.system = l[1].trim();
							break;
						case 'machine':
							site.cpu.machine = l[1].trim();
							break;
						case 'cpu model':
							site.cpu.model = l[1].trim();
							break;
					}
				}
			}
		}
		else {
			site.cpu.cpuifo = error;
		}
		myApp.logger.log('module', site);
	});




}


function pubProcess() {


    top.os = {};
    top.os.loadavg = os.loadavg();
    top.process = {};
    top.process.pid = process.pid;
    top.process.title = process.title;
    top.process.memoryUsage = process.memoryUsage();
    top.process.uptime = process.uptime();

	exec("free",
	function(error,stdout,stderr) {
		if (error == null) {

			var lines = stdout.split('\n');
		    top.os.totalmem = lines[1].substr(10,13).trim();
	    	top.os.freemem = (lines[1].substr(33,13)).trim();
			//console.log(top);
		} else {
			top.os.totalmem = error;
		}
		myApp.logger.log('top', top);
	});
}
